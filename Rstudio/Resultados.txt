
> 'VALORES DOS PARAMETROS'
[1] "VALORES DOS PARAMETROS"

> '----------------------------------------------------------------'
[1] "----------------------------------------------------------------"

> print(c('a    = ', round(Afinal[1], 5), round(sAfinal[1], 5)))
[1] "a    = " "25.2199" "0"      

> print(c('Alfa =  ', round(Afinal[2], 5), round(sAfinal[2], 5)))
[1] "Alfa =  " "0.0222"   "0"       

> print(c('QUI-QUADRADO', round(chi2novo, 2)))
[1] "QUI-QUADRADO" "18117.43"    

> print(c('QUI-QUADRADO REDUZIDO', round(quirednovo, 2)))
[1] "QUI-QUADRADO REDUZIDO" "1811.74"              

> '----------------------------------------------------------------'
[1] "----------------------------------------------------------------"

> 'VALORES DOS K0S'
[1] "VALORES DOS K0S"

> k0res = 0

> for (i in 1 : N) {
+   k0res[i] = round(Afinal[i+2], 11)
+ }

> k0res = format(matrix(k0res, ncol=1), scientific = TRUE)

> colnames(k0res) = '     k0'

> Isotopo = matrix(Isotopo, ncol=1)

> colnames(Isotopo) = 'Isotopo'

> Egama = matrix(Egama, ncol=1)

> colnames(Egama) = 'E. gamma'

> tabela = format(matrix(k0, ncol=1), scientific = TRUE)

> colnames(tabela) = 'Referencia'

> #sk0res = sAfinal2
> sk0res = round(sAfinal2, 11)

> sk0res = format(matrix(sk0res, ncol=1), scientific = TRUE)

> colnames(sk0res) = '  Incerteza'

> cbind(Isotopo, Egama, k0res, sk0res, tabela)
            [,1]
 [1,]  3.2276332
 [2,] -3.8077991
 [3,]  2.9881838
 [4,]  2.9595524
 [5,]  3.0209048
 [6,]  2.9713581
 [7,]  2.8629645
 [8,]  2.8922905
 [9,]  2.7801687
[10,]  2.5937258
[11,]  2.9045778
[12,]  2.9062696
[13,]  2.9671266
[14,]  2.9653333
[15,]        NaN
[16,]        NaN
[17,]        NaN
[18,]        NaN
[19,]        NaN
[20,]        NaN
[21,]        NaN
[22,]        NaN
[23,] -0.6871207
[24,] -0.6789176
[25,]        NaN
[26,]        NaN
              [,1]
 [1,] 8.971435e+10
 [2,] 1.022445e+00
 [3,] 4.174183e+08
 [4,] 2.383705e+08
 [5,] 8.078124e+08
 [6,] 2.997348e+08
 [7,] 4.036075e+07
 [8,] 6.796951e+07
 [9,] 1.003652e+07
[10,] 6.466293e+05
[11,] 8.494665e+07
[12,] 8.761376e+07
[13,] 2.760221e+08
[14,] 2.665758e+08
[15,] 1.035428e-04
[16,] 1.178865e-04
[17,] 5.388697e-03
[18,] 4.362443e-04
[19,] 2.738543e-02
[20,] 5.947384e-02
[21,] 3.322107e-02
[22,] 1.415656e-01
[23,] 1.653712e+00
[24,] 1.660578e+00
[25,] 5.205610e-01
[26,] 4.653114e-01
              [,1]
 [1,] 8.971435e+10
 [2,] 1.022445e+00
 [3,] 4.174183e+08
 [4,] 2.383705e+08
 [5,] 8.078124e+08
 [6,] 2.997348e+08
 [7,] 4.036075e+07
 [8,] 6.796951e+07
 [9,] 1.003652e+07
[10,] 6.466293e+05
[11,] 8.494665e+07
[12,] 8.761376e+07
[13,] 2.760221e+08
[14,] 2.665758e+08
[15,] 1.035428e-04
[16,] 1.178865e-04
[17,] 5.388697e-03
[18,] 4.362443e-04
[19,] 2.738543e-02
[20,] 5.947384e-02
[21,] 3.322107e-02
[22,] 1.415656e-01              [,1]
 [1,] 8.971435e+10
 [2,] 1.022445e+00
 [3,] 4.174183e+08
 [4,] 2.383705e+08
 [5,] 8.078124e+08
 [6,] 2.997348e+08
 [7,] 4.036075e+07
 [8,] 6.796951e+07
 [9,] 1.003652e+07
[10,] 6.466293e+05
[11,] 8.494665e+07
[12,] 8.761376e+07
[13,] 2.760221e+08
[14,] 2.665758e+08
[15,] 1.035428e-04
[16,] 1.178865e-04
[17,] 5.388697e-03
[18,] 4.362443e-04
[19,] 2.738543e-02
[20,] 5.947384e-02
[21,] 3.322107e-02
[22,] 1.415656e-01
[23,] 1.653712e+00
[24,] 1.660578e+00
[25,] 5.205610e-01
[26,] 4.653114e-01
              [,1]
 [1,] 8.971435e+10
 [2,] 1.022445e+00
 [3,] 4.174183e+08
 [4,] 2.383705e+08
 [5,] 8.078124e+08
 [6,] 2.997348e+08
 [7,] 4.036075e+07
 [8,] 6.796951e+07
 [9,] 1.003652e+07
[10,] 6.466293e+05
[11,] 8.494665e+07
[12,] 8.761376e+07
[13,] 2.760221e+08
[14,] 2.665758e+08
[15,] 1.035428e-04
[16,] 1.178865e-04
[17,] 5.388697e-03
[18,] 4.362443e-04
[19,] 2.738543e-02
[20,] 5.947384e-02
[21,] 3.322107e-02
> #AKFIT R Edition
> #Rafel Vanhoz Ribeiro
> 
> #INICIO
> #escolhendo a biblioteca.
> 
> library(tidyverse)  #Tidtverse Ã© uma coletÃ¢nea de bibliotec .... [TRUNCATED] 

> library(minpack.lm) #minpack Ã© uma biblioteca para realizaÃ§Ã£o do levenberg - marquardt

> library(matlib) #matlib Ã© uma biblioteca que realiza calculos matriciais e inversÃµes de matrizes

> # abrindo o arquivo de dados dos elementos
> data = readLines(file.choose()) #Abre janela pra escolher o arquivo e lÃª suas linhas

> data = data[ - 1] #remove a primeira linha do arquivo (cabeÃ§alho)

> data = data[ - 1] #remove a primeira linha do arquivo apÃ³s remover a primeira linha anterior (nome das colunas)

> data = data.frame(data) #transforma o arquivo de dados e data frame

> data = separate( #funÃ§Ã£o para separar as colunas do arquivo de dados
+   data, "data", c(
+   'Isotopo', 
+   'Egama', 
+   'IN', 
+   'Efic', 
+  .... [TRUNCATED] 

> #transformando cada columa como variÃ¡veis numÃ©ricas
> 
> Isotopo = as.character(data$Isotopo)

> Egama = as.numeric(data$Egama)

> IN = as.numeric(data$IN)

> Efic = as.numeric(data$Efic)

> sEfic = as.numeric(data$sEfic)

> Eres = as.numeric(data$Eres)

> sEres = as.numeric(data$sEres)

> AspCd = as.numeric(data$AspCd)

> sAspCd = as.numeric(data$sAspCd)

> Asp = as.numeric(data$Asp)

> sAsp = as.numeric(data$sAsp)

> Rcd = as.numeric(data$Rcd)

> sRcd = as.numeric(data$sRcd)

> k0 = as.numeric(data$k0)

> sk0 = as.numeric(data$sk0)

> FCd = as.numeric(data$FCd)

> sFCd = as.numeric(data$sFCd)

> Gepi = as.numeric(data$Gepi)

> sGepi = as.numeric(data$sGepi)

> Gth = as.numeric(data$Gth)

> sGth = as.numeric(data$sGth)

> Q0 = as.numeric(data$Q0)

> sQ0 = as.numeric(data$sQ0)

> idouro = as.numeric(data$idouro)

> # abrindo o arquivo de dados dos ouros
> #mesmo procedimento utilizado anteriormente
> dataau = readLines(file.choose())

> dataau = dataau[ - 1]

> dataau = dataau[ - 1]

> dataau = data.frame(dataau)

> dataau = separate(
+   dataau, "dataau", c(
+    'Isotopo', 
+    'Egama', 
+    'IN', 
+    'Efic', 
+    'sEfic', 
+    'Eres', 
+    'sEres', 
+  .... [TRUNCATED] 

> Isotopoau = as.character(dataau$Isotopo)

> Egamaau = as.numeric(dataau$Egama)

> INau = as.numeric(dataau$IN)

> Eficau = as.numeric(dataau$Efic)

> sEficau = as.numeric(dataau$sEfic)

> Eresau = as.numeric(dataau$Eres)

> sEresau = as.numeric(dataau$sEres)

> AspCdau = as.numeric(dataau$AspCd)

> sAspCdau = as.numeric(dataau$sAspCd)

> Aspau = as.numeric(dataau$Asp)

> sAspau = as.numeric(dataau$sAsp)

> Rcdau = as.numeric(dataau$Rcd)

> sRcdau = as.numeric(dataau$sRcd)

> k0au = as.numeric(dataau$k0)

> sk0au = as.numeric(dataau$sk0)

> FCdau = as.numeric(dataau$FCd)

> sFCdau = as.numeric(dataau$sFCd)

> Gepiau = as.numeric(dataau$Gepi)

> sGepiau = as.numeric(dataau$sGepi)

> Gthau = as.numeric(dataau$Gth)

> sGthau = as.numeric(dataau$sGth)

> Q0au = as.numeric(dataau$Q0)

> sQ0au = as.numeric(dataau$sQ0)

> #O comentÃ¡rio abaixo refere - se ao novo padrÃ£o de arquivo de dados para o novo cÃ¡lculo dos parÃ¢metros
> 
> # data2 = readLines(file.choose())
> .... [TRUNCATED] 

> sEresau = sEresau * Eresau / 100

> #Define uma variavel que conta o total de linhas do arquivo de dados
> N = nrow(data)

> #Calcula o Y Superior da matrix Y
> Ys = expression(log(AspCd / (Efic * FCd * Gepi)))

> Ysuperior = eval(Ys)

> #Calcula o Y Medio da Matrix Y
> Ym = expression(((FCdau * (Aspau / AspCdau) - 1) * (Gth * Gepiau)) / ((FCd * (Asp / AspCd) - 1) * (Gthau * Gepi)))

> Ymedio = 0

> for (i in 1:N) {
+   Ymedio[i] = ((FCdau[idouro[i]] * (Aspau[idouro[i]] / AspCdau[idouro[i]]) - 1) * (Gth[i] * Gepiau[idouro[i]])) / ((FCd[i] * (Asp .... [TRUNCATED] 

> #Calcula o Y Inferior da matrix Y
> Yi = expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic)))

> Yinferior = 0

> for(i in 1:N){
+   Yinferior[i] = log(((Asp[i] - AspCd[i] / FCd[i]) / (Aspau[idouro[i]] - AspCdau[idouro[i]] / FCdau[idouro[i]])) * (Gthau[idouro[i] .... [TRUNCATED] 

> Y = c(Ysuperior, Ymedio, Yinferior)

> #derivadas parciais de Ysuperior e Yinferior
> 
> #Ysuperior
> dYsAspCd = eval(D(Ys,'AspCd'))

> dYsEfic = eval(D(Ys,'Efic'))

> dYsFCd = eval(D(Ys,'FCd'))

> dYsGepi = eval(D(Ys,'Gepi'))

> #Ymedio sem ouro
> dYmAsp = eval(D(Ym, 'Asp'))

> dYmAspCd = eval(D(Ym, 'AspCd'))

> dYmFCd = eval(D(Ym, 'FCd'))

> dYmGth = eval(D(Ym, 'Gth'))

> dYmGepi = eval(D(Ym, 'Gepi'))

> #Ymedio com ouro
> dYmAspauexp = D(expression(((FCdau * (Aspau / AspCdau) - 1) * (Gth * Gepiau)) / ((FCd * (Asp / AspCd) - 1) * (Gthau * Gepi))), 'A .... [TRUNCATED] 

> dYmAspau = eval(FCdau[idouro] * (1/AspCdau[idouro]) * (Gth * Gepiau[idouro])/((FCd * (Asp/AspCd) - 1) * (Gthau[idouro] * Gepi)))

> dYmAspCdauexp = D(expression(((FCdau * (Aspau / AspCdau) - 1) * (Gth * Gepiau)) / ((FCd * (Asp / AspCd) - 1) * (Gthau * Gepi))), 'AspCdau')

> dYmAspCdau = eval(-(FCdau[idouro] * (Aspau[idouro]/AspCdau[idouro]^2) * (Gth * Gepiau[idouro])/((FCd * (Asp/AspCd) - 1) * (Gthau[idouro] * Gepi))))

> dYmFCdauexp = D(expression(((FCdau * (Aspau / AspCdau) - 1) * (Gth * Gepiau)) / ((FCd * (Asp / AspCd) - 1) * (Gthau * Gepi))), 'FCdau')

> dYmFCdau = eval((Aspau[idouro]/AspCdau[idouro]) * (Gth * Gepiau[idouro])/((FCd * (Asp/AspCd) - 1) * (Gthau[idouro] * Gepi)))

> dYmGthauexp = D(expression(((FCdau * (Aspau / AspCdau) - 1) * (Gth * Gepiau)) / ((FCd * (Asp / AspCd) - 1) * (Gthau * Gepi))), 'Gthau')

> dYmGthau = eval(-(((FCdau[idouro] * (Aspau[idouro]/AspCdau[idouro]) - 1) * (Gth * Gepiau[idouro])) * ((FCd * (Asp/AspCd) - 1) * Gepi)/((FCd * (Asp/A .... [TRUNCATED] 

> dYmGepiauexp = D(expression(((FCdau * (Aspau / AspCdau) - 1) * (Gth * Gepiau)) / ((FCd * (Asp / AspCd) - 1) * (Gthau * Gepi))), 'Gepiau')

> dYmGepiau = eval((FCdau[idouro] * (Aspau[idouro]/AspCdau[idouro]) - 1) * Gth/((FCd * (Asp/AspCd) - 1) * (Gthau[idouro] * Gepi)))

> #Yinferior sem ouro
> dYiAsp = eval(D(Yi, 'Asp'))

> dYiAspCd = eval(D(Yi, 'AspCd'))

> dYiFCd = eval(D(Yi, 'FCd'))

> dYiGth = eval(D(Yi, 'Gth'))

> dYiEfic = eval(D(Yi, 'Efic'))

> #Yinferior com ouro
> dYiAspauexp = D(expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic))), 'Aspau')

> dYiAspau = eval( - ((Asp - AspCd / FCd)/(Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])^2 * (Gthau[idouro] / Gth * Eficau[idouro] / Efic)))

> dYiAspCdauexp = D(expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic))), 'AspCdau')

> dYiAspCdau = eval((Asp - AspCd / FCd) * (1 / FCdau[idouro]) / (Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])^2 * (Gthau[idouro] / Gth * Eficau[id .... [TRUNCATED] 

> dYiFCdauexp = D(expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic))), 'FCdau')

> dYiFCdau = eval( - ((Asp - AspCd / FCd) * (AspCdau[idouro] / FCdau[idouro]^2) / (Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])^2 * (Gthau[idouro] .... [TRUNCATED] 

> dYiGthauexp = D(expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic))), 'Gthau')

> dYiGthau = eval(((Asp - AspCd / FCd)/(Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])) * (1 / Gth * Eficau[idouro] / Efic))

> dYiEficauexp = D(expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic))), 'Eficau')

> dYiEficau = eval(((Asp - AspCd/FCd) / (Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])) * (Gthau[idouro] / Gth / Efic))

> #Calculo da Variancia
> 
> varsup = (dYsAspCd * sAspCd)^2 + (dYsEfic * sEfic)^2 + (dYsFCd * sFCd)^2 + (dYsGepi * sGepi)^2

> varmed = (dYmAsp * sAsp)^2 + (dYmAspCd * sAspCd)^2 + (dYmFCd * sFCd)^2 + (dYmGth * sGth)^2 + (dYmGepi * sGepi)^2 + 
+          (dYmAspau * sAspau[id .... [TRUNCATED] 

> varinf = (dYiAsp * sAsp)^2 + (dYiAspCd * sAspCd)^2 + (dYiFCd * sFCd)^2 + (dYiGth * sGth)^2 + (dYiEfic * sEfic)^2 +
+          (dYiAspau * sAspau[ido .... [TRUNCATED] 

> varY = c(varsup,varmed, varinf)

> vY = diag(varY)

> #covariancias entre YSuperior e YSuperior
> for(i in 1:N) {
+   for(j in i + 1:N) {
+     if(isTRUE(Isotopo[i] == Isotopo[j]) & isTRUE(idouro[i] ==  .... [TRUNCATED] 

> #covariancias entre YSuperior e YMedio com Egama igual
> for(i in 1:N) {
+   for(j in (N + 1):(N * 2)) {
+     if(isTRUE(Egama[i]==Egama[j - N]) & i .... [TRUNCATED] 

> #covariancias entre YSuperior e YMedio com Egama diferente
> for(i in 1:N) {
+   for(j in (N +1):(N * 2)) {
+     if(isTRUE(Isotopo[i] == Isotopo[j  .... [TRUNCATED] 

> #covariancias entre YSuperior e YInferior com Egama igual
> for(i in 1:N) {
+   for(j in (N * 2 + 1):(N * 3)) {
+     if(isTRUE(Egama[i]==Egama[j -  .... [TRUNCATED] 

> #covariancias entre YSuperior e YInferior com Egama diferente
> for(i in 1:N) {
+   for(j in (N * 2 + 1):(N * 3)) {
+     if(isTRUE(Isotopo[i] == Is .... [TRUNCATED] 

> #covariancias entre YMedio e YMedio com Isotopo Igual
> for(i in (N + 1):(N * 2)) {
+   for(j in (i + 1):(N * 2)) {
+     if(isTRUE(Isotopo[i - N] = .... [TRUNCATED] 

> #covariancias entre YMedio e YMedio com Isotopo diferente
> for(i in (N + 1):(N * 2)) {
+   for(j in (i + 1):(N * 2)) {
+     if(isTRUE(Isotopo[i -  .... [TRUNCATED] 

> #covariancias entre YMedio e YInferior com Isotopo Igual
> for(i in (N + 1):(N * 2)) {
+   for(j in (N * 2):(N * 3)) {
+     if(isTRUE(Isotopo[i - N .... [TRUNCATED] 

> #covariancias entre YMedio e YInferior com Isotopo Diferente
> for(i in (N + 1):(N * 2)) {
+   for(j in (N * 2):(N * 3)) {
+     if(isTRUE(Isotopo[i .... [TRUNCATED] 

> #covariancias entre YInferior e YInferior com Isotopo Igual
> for(i in (N * 2 + 1):(N * 3)) {
+   for(j in (i + 1):(N * 3)) {
+     if(isTRUE(Isotop .... [TRUNCATED] 

> #covariancias entre YInferior e YInferior com Isotopo diferente
> for(i in (N * 2 + 1):(N * 3)) {
+   for(j in (i + 1):(N * 3)) {
+     if(isTRUE(Is .... [TRUNCATED] 

> #construindo a matrix de planejamento
> #Definindo as variaveis
> Aa = runif(1, min = 22, max = 25)

> Aalfa = runif(1, min = 0.001, max = 0.008)

> AQ0 = 0

> for (i in 1 : N) {
+   AQ0[i] = runif(1, min = 1, max = 10)
+ }

> Ak0 = 0

> for (i in 1 : N) {
+   Ak0[i] = log(runif(1, min = 1, max = 5))
+ }

> A2 = matrix(c(Aa, Aalfa, AQ0, Ak0))

> colsexp = expression(Aa + 2 * Aalfa * log(Eres) * log((((AQ0 - 0.429) / Eres^Aalfa) + (0.429 / ((2 * Aalfa + 1) * 0.55^Aalfa)))) + log(Ak0))

> #cols = D(expression(Aa + 2 * Aalfa * log(Eres) * log((((AQ0 - 0.429) / Eres^Aalfa) + (0.429 / ((2 * Aalfa + 1) * 0.55^Aalfa)))) + log(exp(Ak0))), ' .... [TRUNCATED] 

> colm = rep(0, N)

> coli = rep(0, N)

> col1 = c(cols, colm, coli)

> #cols2 = eval(D(expression(exp(Aa) * Eres^(2* Aalfa) * Ak0 * (((AQ0 - 0.429) / Eres^Aalfa) + (0.429 / ((2 * Aalfa + 1) * 0.55^Aalfa)))), 'Aalfa'))   .... [TRUNCATED] 

> cols2b = 2 * log(Eres) * log((((AQ0 - 0.429)/Eres^Aalfa) + (0.429/((2 * Aalfa + 1) * 0.55^Aalfa)))) - 2 * Aalfa * log(Eres) * ((0.429 * (2 * 0.55^Aa .... [TRUNCATED] 

> colm2exp = expression(log((((AQ0 - 0.429) / Eres^Aalfa) + (0.429 / ((2 * Aalfa + 1) * 0.55^Aalfa))) / (((Q0au - 0.429) / Eresau^Aalfa) + (0.429 / (( .... [TRUNCATED] 

> colm2 = eval(D(colm2exp, 'Aalfa'))

> colm2b = -(((0.429 * (2 * 0.55^Aalfa + (2 * Aalfa + 1) * (0.55^Aalfa * log(0.55)))/((2 * Aalfa + 1) * 0.55^Aalfa)^2 + (AQ0 - 0.429) * (Eres^Aalfa *  .... [TRUNCATED] 

> coli2 = coli = rep(0, N)

> col2 = c(cols2b, colm2b, coli2)

> cols3 = eval(D(colsexp, 'AQ0'))

> cols3b = 2 * Aalfa * log(Eres) * (1/Eres^Aalfa/(((AQ0 - 0.429)/Eres^Aalfa) + (0.429/((2 * Aalfa + 1) * 0.55^Aalfa))))

> colm3 = eval(D(colm2exp, 'AQ0'))

> colm3b = 1/Eres^Aalfa/(((Q0au - 0.429)/Eresau^Aalfa) + (0.429/((2 * Aalfa + 1) * 0.55^Aalfa)))/((((AQ0 - 0.429)/Eres^Aalfa) + (0.429/((2 * Aalfa + 1 .... [TRUNCATED] 

> cols4 = eval(D(colsexp, 'Ak0'))

> Ntotal = N * 3

> XQ0 = matrix(c(0),nrow=Ntotal, ncol = N)

> for(i in 1:N) {
+   XQ0[i,i] = cols3b[i]
+   XQ0[(N + i),i] = colm3b[i]
+ }

> Xk0 = matrix(c(0),nrow=Ntotal, ncol = N)

> for(i in 1:N) {
+   Xk0[i,i] = cols4[i]
+   Xk0[(N * 2 + i),i] = 1
+ }

> X = cbind(col1, col2, XQ0, Xk0)

> #começando o levenberg
> #Vetor A com as variaveis
> 
> 
> Yexp = matrix(Y)

> Yajusup = 0

> Yajumed = 0

> Yajuinf = 0

> R = t(X) %*% inv(vY) %*% X

> #valores de lambda e parametros para o loop na hora de fazer a analise
> chidif = 1

> lambda = 0.000000001

> X2 = 0

> chi2 = -1

> recalcularY = 1

> chi2novo = 0

> while(1) {
+   if(recalcularY == 1) {
+     a2 = A2[1]
+     alfa2 = A2[2]
+     for (i in 1 : N) {
+       Q0b = A2[i + 2]
+       k0b = A2[(i + N  .... [TRUNCATED] 
