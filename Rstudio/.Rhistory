col1 = c(cols, colm, coli)
#cols2 = eval(D(expression(exp(Aa) * Eres^(2* Aalfa) * exp(Ak0) * (((exp(AQ0) - 0.429) / Eres^Aalfa) + (0.429 / ((2 * Aalfa + 1) * 0.55^Aalfa)))), 'Aalfa'))
cols2 = eval(D(colsexp, 'Alfa1'))
colm2 = eval(D(colmexp, 'Alfa1'))
#cols2b = 2 * log(Eres)
#cols2b = 2 * log(Eres) - (0.429 * (2 * 0.55^Alfa1 + (2 * Alfa1 + 1) * (0.55^Alfa1 * log(0.55)))/((2 * Alfa1 + 1) * 0.55^Alfa1)^2 + (Q0 - 0.429) * (Eres^Alfa1 * log(Eres))/(Eres^Alfa1)^2)/(((Q0 - 0.429)/Eres^Alfa1) + (0.429/((2 * Alfa1 + 1) * 0.55^Alfa1)))
#colm2exp = expression((((Q0 - 0.429) / Eres^Aalfa) + (0.429 / ((2 * Aalfa + 1) * 0.55^Aalfa))) / (((Q0au - 0.429) / Eresau^Aalfa) + (0.429 / ((2 * Aalfa + 1) * 0.55^Aalfa))))
#colm2 = rep(0, N) #eval(D(colm2exp, 'Aalfa'))
#colm2b = -((0.429 * (2 * 0.55^Aalfa + (2 * Aalfa + 1) * (0.55^Aalfa * log(0.55)))/((2 * Aalfa + 1) * 0.55^Aalfa)^2 + (Q0 - 0.429) * (Eres^Aalfa * log(Eres))/(Eres^Aalfa)^2)/(((Q0au[idouro] - 0.429)/Eresau[idouro]^Aalfa) + (0.429/((2 * Aalfa + 1) * 0.55^Aalfa))) - (((Q0 - 0.429)/Eres^Aalfa) + (0.429/((2 * Aalfa + 1) * 0.55^Aalfa))) * (0.429 * (2 * 0.55^Aalfa + (2 * Aalfa + 1) * (0.55^Aalfa * log(0.55)))/((2 * Aalfa + 1) * 0.55^Aalfa)^2 + (Q0au[idouro] - 0.429) * (Eresau[idouro]^Aalfa * log(Eresau[idouro]))/(Eresau[idouro]^Aalfa)^2)/(((Q0au[idouro] - 0.429)/Eresau[idouro]^Aalfa) + (0.429/((2 * Aalfa + 1) * 0.55^Aalfa)))^2)
coli2 = coli = rep(0, N)
col2 = c(cols2, colm2, coli2)
cols3 = eval(D(colsexp, 'Q0'))
cols3b = 1/Eres^Alfa1/(((Q0 - 0.429)/Eres^Alfa1) + (0.429/((2 * Alfa1 + 1) * 0.55^Alfa1)))
colm3 = eval(D(colmexp, 'Q0'))
colm3b = 1/Eres^Aalfa/(((Q0au[idouro] - 0.429)/Eresau[idouro]^Aalfa) + (0.429/((2 * Aalfa + 1) * 0.55^Aalfa)))
cols4 = eval(D(colsexp, 'k0'))
cols4b = rep(1, N) #/exp(Ak0)
Ntotal = N * 3
XQ0 = matrix(c(0),nrow=Ntotal, ncol = N)
for(i in 1:N) {
XQ0[i,i] = cols3[i]
XQ0[(N + i),i] = colm3[i]
}
Xk0 = matrix(c(0),nrow=Ntotal, ncol = N)
for(i in 1:N) {
Xk0[i,i] = cols4[i]
Xk0[(N * 2 + i),i] = 1
}
X = cbind(col1, col2, XQ0, Xk0)
#começando o levenberg
#Vetor A com as variaveis
Yexp = matrix(Y)
Yajusup = 0
Yajumed = 0
Yajuinf = 0
R = t(X) %*% Ginv(vY) %*% X
#valores de lambda e parametros para o loop na hora de fazer a analise
chidif = 1
lambda = 0.00001
X2 = 0
chi2 = -1
recalcularY = 1
chi2novo = 0
#Yinferior sem ouro
dYiAsp = eval(D(Yi, 'Asp'))
dYiAsp
dYsAspCd
N
nrow(data)
View(data)
Ys
Ysuperior
Ymedio
eval(D(Ys,'AspCd'))
dYsAspCd = eval(D(Ys,'AspCd'))
eval(D(Ym, 'Asp'))
FCdau
Aspau
(FCdau[idouro[i]] * (Aspau[idouro[i]] / AspCdau[idouro[i]]) - 1)
(FCdau[idouro[i]] * (Aspau[idouro[i]] / AspCdau[idouro[i]]) - 1) * (Gth[i]
)
(FCdau[idouro[i]] * (Aspau[idouro[i]] / AspCdau[idouro[i]]) - 1) * (Gth[i] * Gepiau[idouro[i]]))
(FCdau[idouro[i]] * (Aspau[idouro[i]] / AspCdau[idouro[i]]) - 1) * (Gth[i] * Gepiau[idouro[i]])
((FCd[i] * (Asp[i] / AspCd[i]) - 1) * (Gthau[idouro[i]] * Gepi[i])
)
Ymedio[i] = ((FCdau[idouro[i]] * (Aspau[idouro[i]] / AspCdau[idouro[i]]) - 1) * (Gth[i] * Gepiau[idouro[i]])) / ((FCd[i] * (Asp[i] / AspCd[i]) - 1) * (Gthau[idouro[i]] * Gepi[i]))
FCdau * (Aspau / AspCdau) - 1) * (Gth * Gepiau)) / ((FCd * (Asp / AspCd) - 1) * (Gthau * Gepi))
((FCdau * (Aspau / AspCdau) - 1) * (Gth * Gepiau)) / ((FCd * (Asp / AspCd) - 1) * (Gthau * Gepi))
FCdau * (Aspau / AspCdau) - 1)
FCdau * (Aspau / AspCdau) - 1
((FCdau * (Aspau / AspCdau) - 1) * (Gth * Gepiau))
((FCdau[idouro] * (Aspau[idouro] / AspCdau[idouro]) - 1) * (Gth * Gepiau[idouro])) / ((FCd * (Asp / AspCd) - 1) * (Gthau[idouro] * Gepi))
source('C:/Users/rafae/OneDrive/Workspace/Rstudio/AKFIT - R Edition.r', echo=TRUE)
#AKFIT R Edition
#Rafel Vanhoz Ribeiro
#INICIO
#escolhendo a biblioteca.
library(tidyverse)  #Tidtverse é uma coletânea de biblioteca para análise de dados
library(minpack.lm) #minpack é uma biblioteca para realização do levenberg - marquardt
library(matlib) #matlib é uma biblioteca que realiza calculos matriciais e inversões de matrizes
# abrindo o arquivo de dados dos elementos
data = readLines(file.choose()) #Abre janela pra escolher o arquivo e lê suas linhas
data = data[ - 1] #remove a primeira linha do arquivo (cabeçalho)
data = data[ - 1] #remove a primeira linha do arquivo após remover a primeira linha anterior (nome das colunas)
data = data.frame(data) #transforma o arquivo de dados e data frame
data = separate( #função para separar as colunas do arquivo de dados
data, "data", c(
'Isotopo',
'Egama',
'IN',
'Efic',
'sEfic',
'Eres',
'sEres',
'AspCd',
'sAspCd',
'Asp',
'sAsp',
'Rcd',
'sRcd',
'k0',
'sk0',
'FCd',
'sFCd',
'Gepi',
'sGepi',
'Gth',
'sGth',
'Q0',
'sQ0',
'idouro'),
sep = '\\s{1,}'
)
#transformando cada columa como variáveis numéricas
Isotopo = as.character(data$Isotopo)
Egama = as.numeric(data$Egama)
IN = as.numeric(data$IN)
Efic = as.numeric(data$Efic)
sEfic = as.numeric(data$sEfic)
Eres = as.numeric(data$Eres)
sEres = as.numeric(data$sEres)
AspCd = as.numeric(data$AspCd)
sAspCd = as.numeric(data$sAspCd)
Asp = as.numeric(data$Asp)
sAsp = as.numeric(data$sAsp)
Rcd = as.numeric(data$Rcd)
sRcd = as.numeric(data$sRcd)
k0 = as.numeric(data$k0)
sk0 = as.numeric(data$sk0)
FCd = as.numeric(data$FCd)
sFCd = as.numeric(data$sFCd)
Gepi = as.numeric(data$Gepi)
sGepi = as.numeric(data$sGepi)
Gth = as.numeric(data$Gth)
sGth = as.numeric(data$sGth)
Q0 = as.numeric(data$Q0)
sQ0 = as.numeric(data$sQ0)
idouro = as.numeric(data$idouro)
# abrindo o arquivo de dados dos ouros
#mesmo procedimento utilizado anteriormente
dataau = readLines(file.choose())
dataau = dataau[ - 1]
dataau = dataau[ - 1]
dataau = data.frame(dataau)
dataau = separate(
dataau, "dataau", c(
'Isotopo',
'Egama',
'IN',
'Efic',
'sEfic',
'Eres',
'sEres',
'AspCd',
'sAspCd',
'Asp',
'sAsp',
'Rcd',
'sRcd',
'k0',
'sk0',
'FCd',
'sFCd',
'Gepi',
'sGepi',
'Gth',
'sGth',
'Q0',
'sQ0'),
sep = '\\s{1,}'
)
Isotopoau = as.character(dataau$Isotopo)
Egamaau = as.numeric(dataau$Egama)
INau = as.numeric(dataau$IN)
Eficau = as.numeric(dataau$Efic)
sEficau = as.numeric(dataau$sEfic)
Eresau = as.numeric(dataau$Eres)
sEresau = as.numeric(dataau$sEres)
AspCdau = as.numeric(dataau$AspCd)
sAspCdau = as.numeric(dataau$sAspCd)
Aspau = as.numeric(dataau$Asp)
sAspau = as.numeric(dataau$sAsp)
Rcdau = as.numeric(dataau$Rcd)
sRcdau = as.numeric(dataau$sRcd)
k0au = as.numeric(dataau$k0)
sk0au = as.numeric(dataau$sk0)
FCdau = as.numeric(dataau$FCd)
sFCdau = as.numeric(dataau$sFCd)
Gepiau = as.numeric(dataau$Gepi)
sGepiau = as.numeric(dataau$sGepi)
Gthau = as.numeric(dataau$Gth)
sGthau = as.numeric(dataau$sGth)
Q0au = as.numeric(dataau$Q0)
sQ0au = as.numeric(dataau$sQ0)
#O comentário abaixo refere - se ao novo padrão de arquivo de dados para o novo cálculo dos parâmetros
# data2 = readLines(file.choose())
# data2 = data2[ - 1]
# data2 = data2[ - 1]
# data2 = data.frame(data2)
#
# data2 = separate(
#   data2, "data2", c(
#   'Isotopo',
#   'N',
#   'sN',
#   'NCd',
#   'sNCd',
#   'fz',
#   'sfz',
#   'fzCd',
#   'sfzCd',
#   'fa',
#   'sfa',
#   'faCd',
#   'sfaCd',
#   'D',
#   'sD',
#   'DCd',
#   'sDCd',
#   'C',
#   'Sc',
#   'CCd',
#   'sCCd',
#   'S',
#   'sS',
#   'SCd',
#   'sSCd',
#   'w',
#   'sw',
#   'wCd',
#   'swCd',
#   'Egama',
#   'IN',
#   'Efic',
#   'sEfic',
#   'Eres',
#   'sEres',
#   'k0',
#   'sk0',
#   'Fcd',
#   'sFCd',
#   'Gepi',
#   'sGepi',
#   'Gth',
#   'sGth',
#   'Q0',
#   'sigma',
#   'idouro'),
#   sep = '\\s{1,}'
# )
#
# # data2au = readLines(file.choose())
# # data2au = data2au[ - 1]
# # data2au = data2au[ - 1]
# # data2au = data.frame(data2au)
#
# data2au = separate(
#   data2au, "data2au", c(
#   'Isotopo',
#   'N',
#   'sN',
#   'NCd',
#   'sNCd',
#   'fz',
#   'sfz',
#   'fzCd',
#   'sfzCd',
#   'fa',
#   'sfa',
#   'faCd',
#   'sfaCd',
#   'D',
#   'sD',
#   'DCd',
#   'sDCd',
#   'C',
#   'Sc',
#   'CCd',
#   'sCCd',
#   'S',
#   'sS',
#   'SCd',
#   'sSCd',
#   'w',
#   'sw',
#   'wCd',
#   'swCd',
#   'Egama',
#   'IN',
#   'Efic',
#   'sEfic',
#   'Eres',
#   'sEres',
#   'k0',
#   'sk0',
#   'Fcd',
#   'sFCd',
#   'Gepi',
#   'sGepi',
#   'Gth',
#   'sGth',
#   'Q0',
#   'sigma'),
#   sep = '\\s{1,}'
# )
#Calcula erro da Enegia de Ressonancia (sEres)
sEres = sEres * Eres / 100
sEresau = sEresau * Eresau / 100
#Define uma variavel que conta o total de linhas do arquivo de dados
N = nrow(data)
#Calcula o Y Superior da matrix Y
Ys = expression(log(AspCd / Q0 / Efic / FCd / Gepi))
Ysuperior = eval(Ys)
#Calcula o Y Inferior da matrix Y
Yi = expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic)))
Yinferior = 0
for(i in 1:N){
Yinferior[i] = log(((Asp[i] - AspCd[i] / FCd[i]) / (Aspau[idouro[i]] - AspCdau[idouro[i]] / FCdau[idouro[i]])) * (Gthau[idouro[i]] / Gth[i] * Eficau[idouro[i]] / Efic[i]))
}
Y = c(Ysuperior,Yinferior)
#derivadas parciais de Ysuperior e Yinferior
#Ysuperior
dYsAspCd = eval(D(Ys,'AspCd'))
dYsQ0 = eval(D(Ys,'Q0'))
dYsEfic = eval(D(Ys,'Efic'))
dYsFCd = eval(D(Ys,'FCd'))
dYsGepi = eval(D(Ys,'Gepi'))
#Yinferior sem ouro
dYiAsp = eval(D(Yi, 'Asp'))
dYiAspCd = eval(D(Yi, 'AspCd'))
dYiFCd = eval(D(Yi, 'FCd'))
dYiGth = eval(D(Yi, 'Gth'))
dYiEfic = eval(D(Yi, 'Efic'))
#Yinferior com ouro
dYiAspauexp = D(expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic))), 'Aspau')
dYiAspau = eval( - ((Asp - AspCd / FCd) / (Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])^2 * (Gthau[idouro] / Gth *
Eficau[idouro] / Efic) / (((Asp - AspCd / FCd) / (Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])) * (Gthau[idouro] /
Gth * Eficau[idouro] / Efic))))
dYiAspCdauexp = D(expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic))), 'AspCdau')
dYiAspCdau = eval((Asp - AspCd / FCd) * (1 / FCdau[idouro]) / (Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])^2 *
(Gthau[idouro] / Gth * Eficau[idouro] / Efic) / (((Asp - AspCd / FCd) / (Aspau[idouro] - AspCdau[idouro] /
FCdau[idouro])) * (Gthau[idouro] / Gth * Eficau[idouro] / Efic)))
dYiFCdauexp = D(expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic))), 'FCdau')
dYiFCdau = eval( - ((Asp - AspCd / FCd) * (AspCdau[idouro] / FCdau[idouro]^2) / (Aspau[idouro] - AspCdau[idouro] /
FCdau[idouro])^2 * (Gthau[idouro] / Gth * Eficau[idouro] / Efic) / (((Asp - AspCd / FCd) / (Aspau[idouro] -
AspCdau[idouro] / FCdau[idouro])) * (Gthau[idouro] / Gth * Eficau[idouro] / Efic))))
dYiGthauexp = D(expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic))), 'Gthau')
dYiGthau = eval(((Asp - AspCd / FCd) / (Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])) * (1 / Gth * Eficau[idouro] / Efic) /
(((Asp - AspCd / FCd) / (Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])) * (Gthau[idouro] / Gth * Eficau[idouro] / Efic)))
dYiEficauexp = D(expression(log(((Asp - AspCd / FCd) / (Aspau - AspCdau / FCdau)) * (Gthau / Gth * Eficau / Efic))), 'Eficau')
dYiEficau = eval(((Asp - AspCd / FCd) / (Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])) * (Gthau[idouro] / Gth / Efic) /
(((Asp - AspCd / FCd) / (Aspau[idouro] - AspCdau[idouro] / FCdau[idouro])) * (Gthau[idouro] / Gth * Eficau[idouro] / Efic)))
#Calculo da Variancia
varsup = (dYsAspCd * sAspCd)^2 + (dYsQ0 * sQ0)^2 + (dYsEfic * sEfic)^2 + (dYsFCd * sFCd)^2 + (dYsGepi * sGepi)^2
varinf = (dYiAsp * sAsp)^2 + (dYiAspCd * sAspCd)^2 + (dYiFCd * sFCd)^2 + (dYiGth * sGth)^2 + (dYiEfic * sEfic)^2 +
(dYiAspau * sAspau[idouro])^2 + (dYiAspCdau * sAspCdau[idouro])^2 + (dYiFCdau * sFCdau[idouro])^2 +
(dYiGthau * sGthau[idouro])^2 + (dYiEficau * sEficau[idouro])^2
varY = c(varsup,varinf)
vY = diag(varY)
for(i in 1:N) {
for(j in i + 1:N) {
if(isTRUE(Isotopo[i] == Isotopo[j]) & isTRUE(idouro[i] == idouro[j])) {
vY[i,j] = dYsQ0[i] * dYsQ0[j] * sQ0[i]^2 + dYsFCd[i] * dYsFCd[j] * sFCd[i]^2 + dYsGepi[i] * dYsGepi[j] * sGepi[i]^2
vY[j,i] = vY[i,j]
}
}
}
for(i in 1:N) {
for(j in (N + 1):(N * 2)) {
if(isTRUE(Egama[i]==Egama[j - N]) & isTRUE(idouro[i]==idouro[j - N])) {
k = j - N
vY[i,j] = dYsAspCd[i] * dYiAspCd[k] * sAspCd[i]^2 + dYsFCd[i] * dYiFCd[k] * sFCd[i]^2 + dYsEfic[i] * dYiEfic[k] * sEfic[i]^2
vY[j,i] = vY[i,j]
}
}
}
for(i in 1:N) {
for(j in (N + 1):(N * 2)) {
if(isTRUE(Isotopo[i] == Isotopo[j - N]) & isFALSE(Egama[i] == Egama[j - N]) & isTRUE(idouro[i] == idouro[j - N])) {
k = j - N
vY[i,j] = dYsFCd[i] * dYiFCd[k] * sFCd[i]^2
vY[j,i] = vY[i,j]
}
}
}
for(i in (N + 1):(N * 2)) {
for(j in (i + 1):(N * 2)) {
if(isTRUE(Isotopo[i - N] == Isotopo[j - N]) & isFALSE(Egama[i - N] == Egama[j - N]) & isTRUE(idouro[i - N]==idouro[j - N])) {
k = i - N
l = j - N
vY[i,j] = dYiAspCdau[idouro[k]] * dYiAspCdau[idouro[l]] * sAspCdau[idouro[k]]^2 + dYiAspau[idouro[k]] * dYiAspau[idouro[l]] *
sAspau[idouro[k]]^2 + dYiFCdau[idouro[k]] * dYiFCdau[idouro[l]] * sFCdau[idouro[k]]^2 + dYiGthau[idouro[k]] *
dYiGthau[idouro[l]] * sGthau[idouro[k]]^2 + dYiEficau[idouro[k]] * dYiEficau[idouro[l]] * sEficau[idouro[k]]^2 +
dYiGth[k] * dYiGth[l] * sGth[k]^2 + dYiFCd[k] * dYiFCd[l] * sFCd[k]^2
vY[j,i] = vY[i,j]
}
}
}
for(i in (N + 1):(N * 2)) {
for(j in (i + 1):(N * 2)) {
if(isTRUE(Isotopo[i - N] != Isotopo[j - N]) & isTRUE(idouro[i - N] == idouro[j - N])) {
k = i - N
l = j - N
vY[i,j] = dYiAspCdau[idouro[k]] * dYiAspCdau[idouro[l]] * sAspCdau[idouro[k]]^2 + dYiAspau[idouro[k]] * dYiAspau[idouro[l]] *
sAspau[idouro[k]]^2 + dYiFCdau[idouro[k]] * dYiFCdau[idouro[l]] * sFCdau[idouro[k]]^2 + dYiGthau[idouro[k]] *
dYiGthau[idouro[l]] * sGthau[idouro[k]]^2 + dYiEficau[idouro[k]] * dYiEficau[idouro[l]] * sEficau[idouro[k]]^2
vY[j,i] = vY[i,j]
}
}
}
#construindo a matrix de planejamento
cols = rep(1, N)
coli = rep(0, N)
col1 = c(cols, coli)
cols2 = 0
for(i in 1:N) {
cols2[i] = ((Q0[i] + 0.429) * log(Eres[i]) - 0.602) / Q0[i]
}
coli2 = rep(0, N)
col2 = c(cols2, coli2)
Ntotal = N * 2
X = matrix(c(0),nrow=Ntotal, ncol = N)
for(i in 1:N) {
X[i,i] = 1
X[(N + i),i] = 1
}
X = cbind(col1, col2, X)
DNase
View(DNase)
DNase1 <- subset(DNase, Run == 1)
DNase1
plot(DNase1$conc, DNase1$density)
nls(density ~ 1/(1 + exp((xmid - log(conc))/scal)),
data = DNase1,
start = list(xmid = 0, scal = 1),
algorithm = "plinear")
nls(density,
data = DNase1,
start = list(xmid = 0, scal = 1),
algorithm = "plinear")
nls(density,
data = DNase1,
start = list(xmid = 0, scal = 1),
algorithm = "plinear")
nls(density ~ 1,
data = DNase1,
start = list(xmid = 0, scal = 1),
algorithm = "plinear")
nls(density ~,
data = DNase1,
start = list(xmid = 0, scal = 1),
algorithm = "plinear")
nls(density ~,
data = DNase1,
start = list(xmid = 0, scal = 1),
)
nls(density ~1,
data = DNase1,
start = list(xmid = 0, scal = 1),
)
nls(density,
data = DNase1,
start = list(xmid = 0, scal = 1),
)
nls(density,
data = DNase1,
,
)
DNase
DNase1
nls(Yajusup ~ a2 + ((alfa2 / Q0[i]) * ((Q0[i] + 0.429) * log(Eres[i]) - 0.602)) + log(exp(k0b)),
data = data,
start = list(a2=22, alfa2 = 0.001, k0b = 0.0008))
nls(Yajusup ~ a2 + ((alfa2 / Q0[i]) * ((Q0[i] + 0.429) * log(Eres[i]) - 0.602)) + log(exp(k0b)),
data = Ysuperior,
start = list(a2=22, alfa2 = 0.001, k0b = 0.0008))
lm(Ysuperior, Yajusup)
data.frame(Ysuperior)
qq=data.frame(Ysuperior)
nls(Yajusup ~ a2 + ((alfa2 / Q0[i]) * ((Q0[i] + 0.429) * log(Eres[i]) - 0.602)) + log(exp(k0b)),
data = qq,
start = list(a2=22, alfa2 = 0.001, k0b = 0.0008))
cbind(data,qq)
nls(Ysuperior ~ a2 + ((alfa2 / Q0[i]) * ((Q0[i] + 0.429) * log(Eres[i]) - 0.602)) + log(exp(k0b)),
data = data,
start = list(a2=22, alfa2 = 0.001, k0b = 0.0008))
nls(Ysuperior ~ a2 + ((alfa2 / Q0[i]) * ((Q0 + 0.429) * log(Eres) - 0.602)) + log(exp(k0b)),
data = data,
start = list(a2=22, alfa2 = 0.001, k0b = 0.0008))
nls(Ysuperior ~ a2 + ((alfa2 / Q0) * ((Q0 + 0.429) * log(Eres) - 0.602)) + log(exp(k0b)),
data = data,
start = list(a2=22, alfa2 = 0.001, k0b = 0.0008))
View(data)
nls(Ysuperior ~ a2 + ((alfa2 / Q0) * ((Q0 + 0.429) * log(Eres) - 0.602)) + log(exp(k0b)),
data = data,
start = list(a2=22, alfa2 = 0.001, k0b = 0.0008))
df <- data.frame(a = c(9,8,7), b = c(6, 5, 4), c(3, 2, 1)
)
df[[2]][[2]]
df$b[2]
y<-2 f<-function(x){ y <- 1; y2 + g(x)} g<-function(x) { x + y }
y = 2 f<-function(x){ y <- 1; y2 + g(x)} g<-function(x) { x + y }
f<-function(x){ y <- 1; y2 + g(x)} g<-function(x) { x + y }
f = function(x){ y <- 1; y2 + g(x)} g<-function(x) { x + y }
f = function(x){ y <- 1; y2
}
g(x)} g<-function(x) { x + y }
g<-function(x) { x + y }
f<-function(x){ y <- 1; y2 + g(x)} g<-function(x) { x + y }
x = c(1,3,5,7)
y=list(4:7)
x*y[[1]]
